1)
int value = 10;
void* pvalue = value; //поинтэру должен присваиваться адрес ячейки то есть (&value)
//поинтер не может быть типа void он же должен что то хранить

// дополнение
*(int*) pvalue = 0;
2)при выходе из функции локальная переменная boris уничтожится, соответсвенно будет не на что ссылаться

3) необходимо объявить глобальную переменную и через ifndef сделать проверку на неё(define нужно занести в условное выполнение, чтобы она выполнялась лишь раз)

#ifndef UNIQUE_NAME;
/.../
#define UNIQUE_NAME();
#endif
//в другом файле можно дописать сточку #undef UNIQUE_NAME и вставтить его между #include "mylib.h"

как объяснял препод по проге, это нужно для осуществления One Definition Rule
ломается этот метод если уникальное имя становится неуникальным, например такое же имя было определено в другом хэдэре
4)
struct Complex {
	int re;
	int im;
	Complex operator+ (const Complex& other) const {
		return { re + other.re,im + other.im };
	}
	Complex operator* (const Complex& other) const {
		return { re * other.re - im * other.im, re*other.im +other.re*im };
	}
	bool operator< (const Complex& other)	 const {
		return { re * re + im * im < other.re* other.re + other.im * other.im };
	}
	bool operator> (const Complex& other) const {
		return { re * re + im * im > other.re* other.re + other.im * other.im };
	}
};
//гарантией того что объекты не иззменятся служит то, что первый объект никак не меняется, а второй применяется по константной ссылке.
//бинарная система чисел с плавающей точкой не позволит нормально складывать числа(например 1/3 будет в десятичной системе представлена как 0,(3) и при умножении на три будет выходить 0,(9))

5)
тип Т должен уметь копироваться и сравниваться.
1) я заменил тип у b на конст Т тк мы его никак не меняем
2) заменил тип у а так как мы её меняем.
struct T{
	bool operator!= (const T& other){
            cout<<"saint-";
            return true;
    }
	T operator= (const T& other){ 
			
            cout<<"Petersburg!";
			return *this;
    }
};
template<class T>
void strange_assign(T& a, const T& b) {
	if(a != b)
		a = b;	
}
